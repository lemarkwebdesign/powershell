Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# =========================
# CONFIG (set once and forget)
# =========================
$DevicesFileName = "devices.txt"
$LocalFileName   = "payload.bin"
$RemotePath      = "/var/tmp/payload.bin"
$PscpPath        = "pscp.exe"
$Port            = 22
$Protocol        = "scp"   # "scp" or "sftp"
# =========================

function ConvertTo-PlainText([Security.SecureString]$Secure) {
    $bstr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($Secure)
    try { [Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr) }
    finally { [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
}

function Convert-UnitToBytes {
    param(
        [double]$Value,
        [string]$Unit
    )
    switch -Regex ($Unit) {
        '^(B)$'  { return [long]($Value) }
        '^(kB|KB)$' { return [long]($Value * 1000) }
        '^(KiB)$'   { return [long]($Value * 1024) }
        '^(MB)$'    { return [long]($Value * 1000 * 1000) }
        '^(MiB)$'   { return [long]($Value * 1024 * 1024) }
        '^(GB)$'    { return [long]($Value * 1000 * 1000 * 1000) }
        '^(GiB)$'   { return [long]($Value * 1024 * 1024 * 1024) }
        default { return 0 }
    }
}

function Invoke-PscpWithLiveProgress {
    param(
        [string]$PscpPath,
        [string]$Device,
        [int]$Port,
        [string]$Username,
        [string]$Password,
        [string]$LocalPath,
        [string]$RemotePath,
        [string]$Protocol,
        [string]$ActivityLabel,
        [long]$TotalBytes
    )

    # NOTE:
    # - No -batch: we auto-answer "Store key in cache? (y/n)" by writing "y" to stdin.
    # - PuTTY progress often updates using carriage returns (\r) without newlines.
    $args = New-Object System.Collections.Generic.List[string]
    $args.Add("-no-sanitise-stderr")
    $args.Add("-P");  $args.Add("$Port")
    $args.Add("-l");  $args.Add($Username)
    $args.Add("-pw"); $args.Add($Password)
    if ($Protocol -eq "sftp") { $args.Add("-sftp") } else { $args.Add("-scp") }
    $args.Add($LocalPath)
    $args.Add("$Device`:$RemotePath")

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $PscpPath
    $psi.Arguments = ($args -join " ")
    $psi.UseShellExecute = $false
    $psi.RedirectStandardInput  = $true
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError  = $true
    $psi.CreateNoWindow = $true

    $p = New-Object System.Diagnostics.Process
    $p.StartInfo = $psi
    $null = $p.Start()

    # Auto-accept host key prompt (first-time hosts)
    $p.StandardInput.WriteLine("y")
    $p.StandardInput.Flush()

    $stderrReader = $p.StandardError
    $stdoutReader = $p.StandardOutput

    $stderrAll = New-Object System.Text.StringBuilder
    $stdoutAll = ""

    $percent = 0
    $speedText = ""
    $transferredBytes = 0

    # Patterns:
    # 1) percent (if present)
    $rxPct = [regex]"(?i)\b(?<pct>\d{1,3})%\b"

    # 2) speed (kB/s, KiB/s, MB/s, MiB/s, etc.)
    $rxSpeed = [regex]"(?i)\b(?<spd>\d+(?:\.\d+)?)\s*(?<unit>kB/s|KB/s|KiB/s|MB/s|MiB/s|GB/s|GiB/s|B/s)\b"

    # 3) transferred size (avoid /s)
    $rxXfer = [regex]"(?i)\b(?<xfer>\d+(?:\.\d+)?)\s*(?<unit>kB|KB|KiB|MB|MiB|GB|GiB|B)\b(?!/s)"

    # Read STDERR character-by-character to handle \r updates.
    $current = New-Object System.Text.StringBuilder

    while (-not $p.HasExited) {
        while (-not $stderrReader.EndOfStream) {
            $ch = $stderrReader.Read()
            if ($ch -lt 0) { break }
            $c = [char]$ch

            # Append everything to full stderr (for logs)
            [void]$stderrAll.Append($c)

            if ($c -eq "`r" -or $c -eq "`n") {
                $line = $current.ToString()
                $current.Clear() | Out-Null

                if (-not [string]::IsNullOrWhiteSpace($line)) {
                    # Parse percent
                    $m1 = $rxPct.Match($line)
                    if ($m1.Success) {
                        $pctVal = [int]$m1.Groups["pct"].Value
                        if ($pctVal -ge 0 -and $pctVal -le 100) { $percent = $pctVal }
                    }

                    # Parse speed
                    $m2 = $rxSpeed.Match($line)
                    if ($m2.Success) {
                        $speedText = "$($m2.Groups['spd'].Value) $($m2.Groups['unit'].Value)"
                    }

                    # Parse transferred size (best effort)
                    # Take the largest parsed transferred amount from the line to avoid grabbing small unrelated numbers.
                    $bestBytes = $null
                    foreach ($m in $rxXfer.Matches($line)) {
                        $val = [double]$m.Groups["xfer"].Value
                        $unit = $m.Groups["unit"].Value
                        $b = Convert-UnitToBytes -Value $val -Unit $unit
                        if ($b -gt 0 -and (($bestBytes -eq $null) -or ($b -gt $bestBytes))) {
                            $bestBytes = $b
                        }
                    }
                    if ($bestBytes -ne $null) {
                        $transferredBytes = [long]$bestBytes
                        if ($TotalBytes -gt 0) {
                            $calcPct = [int][math]::Floor(([double]$transferredBytes / [double]$TotalBytes) * 100)
                            if ($calcPct -gt $percent) { $percent = [math]::Min(100, $calcPct) }
                        }
                    }

                    $statusLine = if ($speedText) {
                        "Progress: $percent% | Speed: $speedText"
                    } else {
                        "Progress: $percent%"
                    }

                    Write-Progress -Activity $ActivityLabel -Status $statusLine -PercentComplete $percent
                }
            }
            else {
                [void]$current.Append($c)
            }
        }

        Start-Sleep -Milliseconds 120
    }

    # Drain remaining output
    try { $stdoutAll = $stdoutReader.ReadToEnd() } catch { }

    try {
        while (-not $stderrReader.EndOfStream) {
            $ch = $stderrReader.Read()
            if ($ch -lt 0) { break }
            [void]$stderrAll.Append([char]$ch)
        }
    } catch { }

    $p.WaitForExit()
    Write-Progress -Activity $ActivityLabel -Completed

    [pscustomobject]@{
        ExitCode       = $p.ExitCode
        StdOut         = $stdoutAll
        StdErr         = $stderrAll.ToString()
        LastPct        = $percent
        LastSpeed      = $speedText
        Transferred    = $transferredBytes
        Args           = $psi.Arguments
    }
}

# Paths relative to script location
$ScriptDir   = Split-Path -Parent $PSCommandPath
$DevicesPath = Join-Path $ScriptDir $DevicesFileName
$LocalPath   = Join-Path $ScriptDir $LocalFileName

if (-not (Test-Path -LiteralPath $DevicesPath)) { throw "Missing devices list file: $DevicesPath" }
if (-not (Test-Path -LiteralPath $LocalPath))   { throw "Missing local file to copy: $LocalPath" }

try { $null = Get-Command $PscpPath -ErrorAction Stop }
catch { throw "pscp.exe not found. Put it in PATH or set `$PscpPath` to a full path." }

# Load devices (always as array)
$Devices = @(
    Get-Content -LiteralPath $DevicesPath |
        ForEach-Object { $_.Trim() } |
        Where-Object { $_ -and -not $_.StartsWith("#") } |
        Sort-Object -Unique
)
if ($Devices.Count -eq 0) { throw "No devices found in $DevicesPath" }

# Prompt once for credentials
$Username   = Read-Host "Enter SSH username"
$SecurePass = Read-Host "Enter SSH password (will be passed to pscp -pw)" -AsSecureString
$Password   = ConvertTo-PlainText $SecurePass
if ([string]::IsNullOrWhiteSpace($Username) -or [string]::IsNullOrWhiteSpace($Password)) {
    throw "Username/password cannot be empty."
}

# Total size for percent calculation
$TotalBytes = (Get-Item -LiteralPath $LocalPath).Length

# Logging
$RunStamp = Get-Date -Format "yyyyMMdd_HHmmss"
$OutDir   = Join-Path $ScriptDir "out_$RunStamp"
New-Item -ItemType Directory -Path $OutDir -Force | Out-Null

$CsvPath = Join-Path $OutDir "results.csv"
$ErrLog  = Join-Path $OutDir "errors.log"

$results = New-Object System.Collections.Generic.List[object]

Write-Host "Starting copy to $($Devices.Count) devices (sequential)..." -ForegroundColor Cyan
Write-Host "Protocol   : $Protocol"
Write-Host "Local file : $LocalPath ($TotalBytes bytes)"
Write-Host "Remote path: $RemotePath"
Write-Host "Output dir : $OutDir"
Write-Host ""

$index = 0
foreach ($Device in $Devices) {
    $index++
    $start = Get-Date
    Write-Host "[$($start.ToString('HH:mm:ss'))] ($index/$($Devices.Count)) $Device"

    $status = "UNKNOWN"
    $exit   = $null
    $msg    = ""
    $stderrFinal = ""
    $lastPct = 0
    $lastSpeed = ""

    try {
        $t = Test-NetConnection -ComputerName $Device -Port $Port -WarningAction SilentlyContinue
        if (-not $t.TcpTestSucceeded) { throw "Port $Port unreachable" }

        $activity = "Copying to $Device ($index/$($Devices.Count))"
        $r = Invoke-PscpWithLiveProgress -PscpPath $PscpPath -Device $Device -Port $Port `
                                         -Username $Username -Password $Password `
                                         -LocalPath $LocalPath -RemotePath $RemotePath `
                                         -Protocol $Protocol -ActivityLabel $activity `
                                         -TotalBytes $TotalBytes

        $exit = $r.ExitCode
        $stderrFinal = $r.StdErr
        $lastPct = $r.LastPct
        $lastSpeed = $r.LastSpeed

        if ($r.ExitCode -eq 0) {
            $status = "OK"
            $msg = if ($lastSpeed) { "Copied (last speed: $lastSpeed)" } else { "Copied" }
            Write-Host "  Result: OK" -ForegroundColor Green
        } else {
            $status = "FAILED"
            $msg = "pscp exit code $($r.ExitCode)"
            Write-Host "  Result: FAILED (exit $($r.ExitCode))" -ForegroundColor Red
        }
    }
    catch {
        $status = "FAILED"
        $msg = $_.Exception.Message
        Write-Host "  Result: FAILED ($msg)" -ForegroundColor Red
    }

    $end = Get-Date
    $sec = [math]::Round(($end - $start).TotalSeconds, 2)

    $results.Add([pscustomobject]@{
        device      = $Device
        status      = $status
        exit_code   = $exit
        seconds     = $sec
        message     = $msg
        protocol    = $Protocol
        last_pct    = $lastPct
        last_speed  = $lastSpeed
        stderr      = ($stderrFinal -replace "\r","" -replace "\n"," | ").Trim()
        started_at  = $start.ToString("s")
        finished_at = $end.ToString("s")
    }) | Out-Null

    if ($status -ne "OK") {
        $line = "{0} | {1} | exit={2} | {3}" -f $end.ToString("s"), $Device, $exit, ($stderrFinal.Trim())
        Add-Content -Encoding UTF8 -LiteralPath $ErrLog -Value $line
    }
}

$results | Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $CsvPath

$ok   = @($results | Where-Object { $_.status -eq "OK" }).Count
$fail = @($results | Where-Object { $_.status -ne "OK" }).Count

Write-Host ""
Write-Host "DONE. OK=$ok FAILED=$fail" -ForegroundColor Cyan
Write-Host "Results CSV : $CsvPath"
Write-Host "Errors log  : $ErrLog"
