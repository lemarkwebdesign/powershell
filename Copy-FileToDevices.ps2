Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# =========================
# CONFIG (set once and forget)
# =========================
$DevicesFileName = "devices.txt"
$LocalFileName   = "payload.bin"
$RemotePath      = "/var/tmp/payload.bin"
$PscpPath        = "pscp.exe"
$Port            = 22
$Protocol        = "scp"   # "scp" or "sftp"
$EnableSshLog    = $true  # creates per-device SSH log files
# =========================

function ConvertTo-PlainText([Security.SecureString]$Secure) {
    $bstr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($Secure)
    try { [Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr) }
    finally { [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
}

# Paths relative to script location
$ScriptDir   = Split-Path -Parent $PSCommandPath
$DevicesPath = Join-Path $ScriptDir $DevicesFileName
$LocalPath   = Join-Path $ScriptDir $LocalFileName

if (-not (Test-Path -LiteralPath $DevicesPath)) { throw "Missing devices list file: $DevicesPath" }
if (-not (Test-Path -LiteralPath $LocalPath))   { throw "Missing local file to copy: $LocalPath" }

try { $null = Get-Command $PscpPath -ErrorAction Stop }
catch { throw "pscp.exe not found. Put it in PATH or set `$PscpPath` to a full path." }

# Load devices (always array)
$Devices = @(
    Get-Content -LiteralPath $DevicesPath |
        ForEach-Object { $_.Trim() } |
        Where-Object { $_ -and -not $_.StartsWith("#") } |
        Sort-Object -Unique
)
if ($Devices.Count -eq 0) { throw "No devices found in $DevicesPath" }

# Prompt once for credentials
$Username   = Read-Host "Enter SSH username"
$SecurePass = Read-Host "Enter SSH password (will be passed to pscp -pw)" -AsSecureString
$Password   = ConvertTo-PlainText $SecurePass
if ([string]::IsNullOrWhiteSpace($Username) -or [string]::IsNullOrWhiteSpace($Password)) {
    throw "Username/password cannot be empty."
}

# Output dirs / logs
$RunStamp = Get-Date -Format "yyyyMMdd_HHmmss"
$OutDir   = Join-Path $ScriptDir "out_$RunStamp"
New-Item -ItemType Directory -Path $OutDir -Force | Out-Null

$CsvPath = Join-Path $OutDir "results.csv"
$ErrLog  = Join-Path $OutDir "errors.log"

$results = New-Object System.Collections.Generic.List[object]

Write-Host "Starting copy to $($Devices.Count) devices (sequential)..." -ForegroundColor Cyan
Write-Host "Protocol   : $Protocol"
Write-Host "Local file : $LocalPath"
Write-Host "Remote path: $RemotePath"
Write-Host "Output dir : $OutDir"
Write-Host ""

$index = 0
foreach ($Device in $Devices) {
    $index++
    $start = Get-Date

    # Overall progress (device count)
    $overallPct = [int][math]::Floor((($index - 1) / [double]$Devices.Count) * 100)
    Write-Progress -Activity "Overall progress" -Status "Device $index of $($Devices.Count): $Device" -PercentComplete $overallPct

    Write-Host "[$($start.ToString('HH:mm:ss'))] ($index/$($Devices.Count)) $Device"

    $status = "UNKNOWN"
    $exit   = $null
    $msg    = ""

    try {
        # Quick port check (optional, speeds up failures)
        $t = Test-NetConnection -ComputerName $Device -Port $Port -WarningAction SilentlyContinue
        if (-not $t.TcpTestSucceeded) { throw "Port $Port unreachable" }

        # Build pscp args
        $args = New-Object System.Collections.Generic.List[string]
        $args.Add("-no-sanitise-stderr")
        $args.Add("-P");  $args.Add("$Port")
        $args.Add("-l");  $args.Add($Username)
        $args.Add("-pw"); $args.Add($Password)

        if ($Protocol -eq "sftp") { $args.Add("-sftp") } else { $args.Add("-scp") }

        if ($EnableSshLog) {
            # Per-device SSH protocol log (useful for debugging; does NOT hide progress)
            $safeName = ($Device -replace '[^a-zA-Z0-9\.\-_]', '_')
            $sshLog = Join-Path $OutDir ("sshlog_{0}.txt" -f $safeName)
            $args.Add("-sshlog"); $args.Add($sshLog)
            $args.Add("-logappend")
        }

        $args.Add($LocalPath)
        $args.Add("$Device`:$RemotePath")

        # IMPORTANT:
        # Feed "y" to stdin so first-time host key prompt is accepted automatically,
        # while keeping pscp output visible (progress/speed).
        "y" | & $PscpPath @args

        $exit = $LASTEXITCODE

        if ($exit -eq 0) {
            $status = "OK"
            $msg = "Copied"
            Write-Host "  Result: OK" -ForegroundColor Green
        } else {
            $status = "FAILED"
            $msg = "pscp exit code $exit"
            Write-Host "  Result: FAILED (exit $exit)" -ForegroundColor Red
        }
    }
    catch {
        $status = "FAILED"
        $msg = $_.Exception.Message
        Write-Host "  Result: FAILED ($msg)" -ForegroundColor Red
    }

    $end = Get-Date
    $sec = [math]::Round(($end - $start).TotalSeconds, 2)

    $results.Add([pscustomobject]@{
        device      = $Device
        status      = $status
        exit_code   = $exit
        seconds     = $sec
        message     = $msg
        protocol    = $Protocol
        started_at  = $start.ToString("s")
        finished_at = $end.ToString("s")
    }) | Out-Null

    if ($status -ne "OK") {
        "{0} | {1} | {2}" -f $end.ToString("s"), $Device, $msg |
            Add-Content -Encoding UTF8 -LiteralPath $ErrLog
    }

    Write-Host ""
}

Write-Progress -Activity "Overall progress" -Completed

$results | Export-Csv -NoTypeInformation -Encoding UTF8 -LiteralPath $CsvPath

$ok   = @($results | Where-Object { $_.status -eq "OK" }).Count
$fail = @($results | Where-Object { $_.status -ne "OK" }).Count

Write-Host "DONE. OK=$ok FAILED=$fail" -ForegroundColor Cyan
Write-Host "Results CSV : $CsvPath"
Write-Host "Errors log  : $ErrLog"
